
-- 1) Consolidar get_relatorio_custos_empresa (única fonte da verdade, com paginação opcional)
DROP FUNCTION IF EXISTS public.get_relatorio_custos_empresa(uuid);

CREATE OR REPLACE FUNCTION public.get_relatorio_custos_empresa(
  p_empresa_id uuid,
  p_page_size integer DEFAULT NULL,
  p_page_offset integer DEFAULT NULL
)
RETURNS TABLE (
  cnpj_razao_social text,
  funcionario_nome text,
  funcionario_cpf text,
  valor_individual numeric,
  status text,
  total_cnpj numeric,
  total_count integer
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  WITH base AS (
    SELECT 
      c.razao_social AS cnpj_razao_social,
      f.nome AS funcionario_nome,
      f.cpf AS funcionario_cpf,
      COALESCE(dp.valor_mensal, 0) AS valor_individual,
      f.status::text AS status,
      COALESCE(dp.valor_mensal, 0) AS total_cnpj,
      COUNT(*) OVER() AS total_count
    FROM public.cnpjs c
    INNER JOIN public.funcionarios f ON f.cnpj_id = c.id
    LEFT JOIN public.dados_planos dp ON dp.cnpj_id = c.id
    WHERE c.empresa_id = p_empresa_id
    ORDER BY c.razao_social, f.nome
  )
  SELECT *
  FROM base
  LIMIT p_page_size
  OFFSET p_page_offset;
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_relatorio_custos_empresa(uuid, integer, integer) TO authenticated;

-- 2) Consolidar get_top_empresas_receita (versão segura, por corretora, Array JSONB)
DROP FUNCTION IF EXISTS public.get_top_empresas_receita();

CREATE OR REPLACE FUNCTION public.get_top_empresas_receita()
RETURNS jsonb
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
    v_corretora_id uuid := auth.uid();
    v_result jsonb;
BEGIN
    WITH empresa_metricas AS (
        SELECT 
            e.id,
            e.nome,
            COALESCE(SUM(dp.valor_mensal), 0) AS receita_mensal,
            COUNT(CASE WHEN f.status = 'ativo' THEN 1 END) AS funcionarios_ativos,
            COUNT(CASE WHEN f.status IN ('pendente', 'exclusao_solicitada') THEN 1 END) AS pendencias
        FROM public.empresas e
        LEFT JOIN public.cnpjs c ON c.empresa_id = e.id
        LEFT JOIN public.funcionarios f ON f.cnpj_id = c.id
        LEFT JOIN public.dados_planos dp ON dp.cnpj_id = c.id
        WHERE e.corretora_id = v_corretora_id
        GROUP BY e.id, e.nome
        ORDER BY receita_mensal DESC
        LIMIT 10
    )
    SELECT jsonb_agg(
        jsonb_build_object(
            'id', em.id,
            'nome', em.nome,
            'receita_mensal', em.receita_mensal,
            'funcionarios_ativos', em.funcionarios_ativos,
            'pendencias', em.pendencias
        )
    ) INTO v_result
    FROM empresa_metricas em;

    RETURN COALESCE(v_result, '[]'::jsonb);
END;
$$;

GRANT EXECUTE ON FUNCTION public.get_top_empresas_receita() TO authenticated;

-- 3) Helpers de RLS padronizados (segurança via SECURITY DEFINER)
CREATE OR REPLACE FUNCTION public.get_my_role()
RETURNS text
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT p.role::text
  FROM public.profiles p
  WHERE p.id = auth.uid();
$$;

CREATE OR REPLACE FUNCTION public.get_my_empresa_id()
RETURNS uuid
LANGUAGE sql
SECURITY DEFINER
STABLE
SET search_path = public
AS $$
  SELECT p.empresa_id
  FROM public.profiles p
  WHERE p.id = auth.uid();
$$;

GRANT EXECUTE ON FUNCTION public.get_my_role() TO authenticated;
GRANT EXECUTE ON FUNCTION public.get_my_empresa_id() TO authenticated;

-- 4) Corrigir PK e identidade de mensagens.id (manter bigint com auto-incremento seguro)

-- 4.1 Tornar mensagens.id uma coluna identity se ainda não for
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.columns
    WHERE table_schema = 'public'
      AND table_name = 'mensagens'
      AND column_name = 'id'
      AND is_identity = 'YES'
  ) THEN
    EXECUTE 'ALTER TABLE public.mensagens ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY';
  END IF;
END $$;

-- 4.2 Sincronizar a sequence para iniciar em max(id)+1 (se existir sequence)
DO $$
DECLARE
  seq_name text;
  max_id bigint;
BEGIN
  SELECT pg_get_serial_sequence('public.mensagens', 'id') INTO seq_name;
  IF seq_name IS NOT NULL THEN
    EXECUTE 'SELECT COALESCE(MAX(id), 0) FROM public.mensagens' INTO max_id;
    EXECUTE format('SELECT setval(%L, %s, false)', seq_name, (max_id + 1)::text);
  END IF;
END $$;

-- 4.3 Garantir que existe PK em mensagens.id (sem duplicar constraint)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.table_constraints tc
    WHERE tc.table_schema = 'public'
      AND tc.table_name = 'mensagens'
      AND tc.constraint_type = 'PRIMARY KEY'
  ) THEN
    EXECUTE 'ALTER TABLE public.mensagens ADD CONSTRAINT mensagens_pkey PRIMARY KEY (id)';
  END IF;
END $$;
